// Copyright 2022 Adam Chalkley
//
// https://github.com/atc0005/check-process
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package main

import (
	"errors"
	"fmt"
	"os"

	"github.com/atc0005/check-process/internal/config"
	"github.com/atc0005/check-process/internal/process"
	"github.com/atc0005/check-process/internal/reports"
	"github.com/atc0005/go-nagios"
	"github.com/rs/zerolog"
)

func main() {

	plugin := nagios.NewPlugin()

	// defer this from the start so it is the last deferred function to run
	defer plugin.ReturnCheckResults()

	// Setup configuration by parsing user-provided flags.
	cfg, cfgErr := config.New(config.AppType{Plugin: true})
	switch {
	case errors.Is(cfgErr, config.ErrVersionRequested):
		fmt.Println(config.Version())

		return

	case errors.Is(cfgErr, config.ErrHelpRequested):
		fmt.Println(cfg.Help())

		return

	case cfgErr != nil:

		// We make some assumptions when setting up our logger as we do not
		// have a working configuration based on sysadmin-specified choices.
		consoleWriter := zerolog.ConsoleWriter{Out: os.Stderr, NoColor: true}
		logger := zerolog.New(consoleWriter).With().Timestamp().Caller().Logger()

		logger.Err(cfgErr).Msg("Error initializing application")

		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Error initializing application",
			nagios.StateUNKNOWNLabel,
		)
		plugin.AddError(cfgErr)
		plugin.ExitStatusCode = nagios.StateUNKNOWNExitCode

		return
	}

	if cfg.EmitBranding {
		// If enabled, show application details at end of notification
		plugin.BrandingCallback = config.Branding("Notification generated by ")
	}

	logger := cfg.Log.With().Logger()

	logger.Debug().
		Str("base_path", process.ProcRootDir).
		Msg("Collecting process paths")
	procDirs, err := process.GetProcDirs(process.ProcRootDir)
	if err != nil {
		logger.Error().Err(err).Msg("Failed to evaluate process directories")

		plugin.AddError(err)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Failed to evaluate process directories",
			nagios.StateCRITICALLabel,
		)

		return
	}

	logger.Debug().
		Str("base_path", process.ProcRootDir).
		Int("process_paths", len(procDirs)).
		Msg("Successfully collected process paths")

	processes, err := process.FromProcDirs(procDirs)
	if err != nil {
		logger.Error().Err(err).Msg("Failed to obtain list of process values")

		plugin.AddError(err)
		plugin.ExitStatusCode = nagios.StateCRITICALExitCode
		plugin.ServiceOutput = fmt.Sprintf(
			"%s: Failed to process proc status files",
			nagios.StateCRITICALLabel,
		)

		return
	}

	logger.Debug().
		Int("processes", len(processes)).
		Msg("Collected info on processes")

	logger.Debug().
		Str("my_name", os.Args[0]).
		Int("my_process_id", os.Getpid()).
		Msg("Excluding process of current tool")
	processes = processes.ExcludeMyPID()

	logger.Debug().
		Int("processes", len(processes)).
		Msg("Excluded process of current tool")

	switch {
	case !processes.IsOKState():

		logger.Debug().
			Int("critical_processes", processes.NumCriticalState()).
			Int("warning_processes", processes.NumWarningState()).
			Int("ok_processes", processes.NumOKState()).
			Msg("Problematic processes found")

		plugin.AddError(process.ErrProblemProcessesFound)

		plugin.ExitStatusCode = processes.ServiceState().ExitCode

		plugin.ServiceOutput = reports.CheckProcessOneLineSummary(processes)
		plugin.LongServiceOutput = reports.CheckProcessReport(processes)

		pd := getPerfData(processes)
		if err := plugin.AddPerfData(false, pd...); err != nil {
			logger.Error().
				Err(err).
				Msg("failed to add performance data")

			// Surface the error in plugin output.
			plugin.AddError(err)

			plugin.ExitStatusCode = nagios.StateUNKNOWNExitCode
			plugin.ServiceOutput = fmt.Sprintf(
				"%s: Failed to process performance data metrics",
				nagios.StateUNKNOWNLabel,
			)
		}

		return

	default:

		logger.Debug().Msg("No problematic processes detected")

		plugin.ServiceOutput = reports.CheckProcessOneLineSummary(processes)
		plugin.LongServiceOutput = reports.CheckProcessReport(processes)

		plugin.ExitStatusCode = processes.ServiceState().ExitCode

		pd := getPerfData(processes)
		if err := plugin.AddPerfData(false, pd...); err != nil {
			logger.Error().
				Err(err).
				Msg("failed to add performance data")
		}

		return

	}

}
